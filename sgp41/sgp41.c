/*
 * THIS FILE IS AUTOMATICALLY GENERATED
 *
 * I2C-Generator: 0.3.0
 * Yaml Version: 0.1.0
 * Template Version: 0.7.0-62-g3d691f9
 */
/*
 * Copyright (c) 2021, Sensirion AG
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 *
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 *
 * * Neither the name of Sensirion AG nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "sgp41.h"

#define NO_ERROR 0
#define CRC8_POLYNOMIAL 0x31
#define CRC8_INIT 0xFF
#define CRC8_LEN 1
#define SENSIRION_COMMAND_SIZE 2
#define SENSIRION_WORD_SIZE 2
#define SENSIRION_NUM_WORDS(x) (sizeof(x) / SENSIRION_WORD_SIZE)
#define SENSIRION_MAX_BUFFER_WORDS 32

static sgp41_read_func_t i2c_read_bytes;
static sgp41_write_func_t i2c_write_bytes;
static sgp41_sleep_func_t sys_sleep;

uint8_t sensirion_i2c_generate_crc(const uint8_t* data, uint16_t count);
uint16_t sensirion_i2c_add_command_to_buffer(uint8_t* buffer, uint16_t offset, uint16_t command);
uint16_t sensirion_i2c_add_uint16_t_to_buffer(uint8_t* buffer, uint16_t offset, uint16_t data);
uint16_t sensirion_common_bytes_to_uint16_t(const uint8_t* bytes);

void sgp41_init(sgp41_read_func_t read, sgp41_write_func_t write, sgp41_sleep_func_t sleep)
{
	i2c_read_bytes = read;
	i2c_write_bytes = write;
	sys_sleep = sleep;
}

#define SGP41_I2C_ADDRESS 0x59

int16_t sgp41_execute_conditioning(uint16_t default_rh, uint16_t default_t, uint16_t* sraw_voc)
{
	int8_t result = 0;
    uint8_t buffer[8];
    uint16_t offset = 0;

    offset = sensirion_i2c_add_command_to_buffer(&buffer[0], offset, 0x2612);
    offset = sensirion_i2c_add_uint16_t_to_buffer(&buffer[0], offset, default_rh);
    offset = sensirion_i2c_add_uint16_t_to_buffer(&buffer[0], offset, default_t);

	result = i2c_write_bytes(SGP41_I2C_ADDRESS, &buffer[0], sizeof(offset));
	if (result != 0) return -1;

    sys_sleep(50);

	result = i2c_read_bytes(SGP41_I2C_ADDRESS, &buffer[0], 2);
	if (result != 0) return -2;

    *sraw_voc = sensirion_common_bytes_to_uint16_t(&buffer[0]);
    return NO_ERROR;
}

/*Sends the command to start the conditioning for 50 ms*/
int16_t sgp41_conditioning_cmd(uint16_t default_rh, uint16_t default_t)
{
    int8_t result = 0;
    uint8_t buffer[8];
    uint16_t offset = 0;

    offset = sensirion_i2c_add_command_to_buffer(&buffer[0], offset, 0x2612);
    offset = sensirion_i2c_add_uint16_t_to_buffer(&buffer[0], offset, default_rh);
    offset = sensirion_i2c_add_uint16_t_to_buffer(&buffer[0], offset, default_t);

	result = i2c_write_bytes(SGP41_I2C_ADDRESS, &buffer[0], offset);
	if (result != 0) return -1;
    return NO_ERROR;
}

int16_t sgp41_measure_raw_signals(uint16_t relative_humidity, uint16_t temperature, uint16_t* sraw_voc, uint16_t* sraw_nox)
{
	int8_t result = 0;
    uint8_t buffer[8];
    uint16_t offset = 0;

    offset = sensirion_i2c_add_command_to_buffer(&buffer[0], offset, 0x2619);
    offset = sensirion_i2c_add_uint16_t_to_buffer(&buffer[0], offset, relative_humidity);
    offset = sensirion_i2c_add_uint16_t_to_buffer(&buffer[0], offset, temperature);

	result = i2c_write_bytes(SGP41_I2C_ADDRESS, &buffer[0], offset);
	if (result != 0) return -1;

	sys_sleep(50);

	result = i2c_read_bytes(SGP41_I2C_ADDRESS, &buffer[0], 4);
	if (result != 0) return -2;
    *sraw_voc = sensirion_common_bytes_to_uint16_t(&buffer[0]);
    *sraw_nox = sensirion_common_bytes_to_uint16_t(&buffer[2]);
    return NO_ERROR;
}

int16_t sgp41_measure_raw_cmd(uint16_t rh_comp, uint16_t t_comp)
{
	int8_t result = 0;
    uint8_t buffer[8];
    uint16_t offset = 0;

    offset = sensirion_i2c_add_command_to_buffer(&buffer[0], offset, 0x2619);
    offset = sensirion_i2c_add_uint16_t_to_buffer(&buffer[0], offset, rh_comp);
    offset = sensirion_i2c_add_uint16_t_to_buffer(&buffer[0], offset, t_comp);

	result = i2c_write_bytes(SGP41_I2C_ADDRESS, &buffer[0], offset);
	if (result != 0) return -1;
    return NO_ERROR;
}

int16_t sgp41_read_raw_cmd(uint16_t* sraw_voc, uint16_t* sraw_nox)
{
	int8_t result = 0;
    uint8_t buffer[8];

    // Format of the buffer to be read: SRAW_VOC (2 bytes), CRC (1 byte), SRAW_NOX (2 bytes), CRC (1 byte)
	result = i2c_read_bytes(SGP41_I2C_ADDRESS, &buffer[0], 6);
	if (result != 0) return -2;

    *sraw_voc = sensirion_common_bytes_to_uint16_t(&buffer[0]);
    *sraw_nox = sensirion_common_bytes_to_uint16_t(&buffer[3]);

    return NO_ERROR;
}

int16_t sgp41_execute_self_test(uint16_t* test_result)
{
	int8_t result = 0;
    uint8_t buffer[3];
    uint16_t offset = 0;
    offset = sensirion_i2c_add_command_to_buffer(&buffer[0], offset, 0x280E);

	result = i2c_write_bytes(SGP41_I2C_ADDRESS, &buffer[0], offset);
	if (result != 0) return -1;

    sys_sleep(320);

	result = i2c_read_bytes(SGP41_I2C_ADDRESS, &buffer[0], 2);
	if (result != 0) return -2;
    *test_result = sensirion_common_bytes_to_uint16_t(&buffer[0]);
    return NO_ERROR;
}

int16_t sgp41_turn_heater_off(void)
{
	int8_t result = 0;
    uint8_t buffer[2];
    uint16_t offset = 0;
    offset = sensirion_i2c_add_command_to_buffer(&buffer[0], offset, 0x3615);

	result = i2c_write_bytes(SGP41_I2C_ADDRESS, &buffer[0], offset);
	if (result != 0) return -1;
	sys_sleep(1);
    return NO_ERROR;
}

int16_t sgp41_get_serial_number(uint16_t* serial_number)
{
	int8_t result = 0;
    uint8_t buffer[9];
    uint16_t offset = 0;
    offset = sensirion_i2c_add_command_to_buffer(&buffer[0], offset, 0x3682);

	result = i2c_write_bytes(SGP41_I2C_ADDRESS, &buffer[0], offset);
	if (result != 0) return -1;

	sys_sleep(1);

	result = i2c_read_bytes(SGP41_I2C_ADDRESS, &buffer[0], 6);
	if (result != 0) return -2;

    serial_number[0] = sensirion_common_bytes_to_uint16_t(&buffer[0]);
    serial_number[1] = sensirion_common_bytes_to_uint16_t(&buffer[2]);
    serial_number[2] = sensirion_common_bytes_to_uint16_t(&buffer[4]);

    return NO_ERROR;
}

uint16_t sensirion_i2c_add_command_to_buffer(uint8_t* buffer, uint16_t offset, uint16_t command)
{
    buffer[offset++] = (uint8_t)((command & 0xFF00) >> 8);
    buffer[offset++] = (uint8_t)((command & 0x00FF) >> 0);
    return offset;
}

uint16_t sensirion_i2c_add_uint16_t_to_buffer(uint8_t* buffer, uint16_t offset, uint16_t data)
{
    buffer[offset++] = (uint8_t)((data & 0xFF00) >> 8);
    buffer[offset++] = (uint8_t)((data & 0x00FF) >> 0);
    buffer[offset] = sensirion_i2c_generate_crc(&buffer[offset - SENSIRION_WORD_SIZE], SENSIRION_WORD_SIZE);
    offset++;
    return offset;
}

uint16_t sensirion_common_bytes_to_uint16_t(const uint8_t* bytes)
{
    return (uint16_t)bytes[0] << 8 | (uint16_t)bytes[1];
}

uint8_t sensirion_i2c_generate_crc(const uint8_t* data, uint16_t count)
{
    uint16_t current_byte;
    uint8_t crc = CRC8_INIT;
    uint8_t crc_bit;

    /* calculates 8-Bit checksum with given polynomial */
    for (current_byte = 0; current_byte < count; ++current_byte)
    {
        crc ^= (data[current_byte]);
        for (crc_bit = 8; crc_bit > 0; --crc_bit)
        {
            if (crc & 0x80)
                crc = (crc << 1) ^ CRC8_POLYNOMIAL;
            else
                crc = (crc << 1);
        }
    }
    return crc;
}
